---
title: Programmieren in **R**
subtitle: Ein Einstieg an der 
  Forstlichen Versuchs- und Forschungsanstalt Baden-W&uuml;rttemberg.
author: Dominik Cullmann, Elke Erhardt
---
``` {r, echo = FALSE}
#!/usr/bin/Rscript --vanilla
``` 
# Vorweg
## Du 
... bist mir derzeit unbekannt. 
Aber ich gehe davon aus, dass Du 

* **R** nicht oder fast nicht kennst.  
  Sollte dem nicht so sein: suche Dir eine 
  [sinnvollere Lekt&uuml;re](http://d-nb.info/881127515).
* nicht oder fast nicht programmieren kannst.  
  Sollte dem nicht so sein, werden Dir einige meiner Ausf&uuml;hrungen bekannt
  vorkommen.
* vor einem Standard-Arbeitsplatz-Desktop an der 
  Forstlichen Versuchs- und Forschungsanstalt Baden-W&uuml;rttemberg
  sitzt.  
  Sollte dem nicht so sein: Du wirst den meisten Links in diesem Dokument nicht
  folgen k&ouml;nnen, sie verweisen auf einen internen Server an der 
  Forstlichen Versuchs- und Forschungsanstalt Baden-W&uuml;rttemberg.
  [Im Anhang](#anhang) findest Du aber immerhin die Daten aus den Beispielen
  dieses Dokumentes.


## **R** 
... ist

- ``nicht`` eines der potentiellen Konkurrenzprodukte:  
  [SAS](http://www.sas.com), 
  [SPSS](http://www-01.ibm.com/software/analytics/spss/), 
  ein [Geographisches Informationssystem](https://de.wikipedia.org/wiki/Geoinformationssystem),
  [pyData](http://pydata.org/), 
  [Julia](http://julialang.org/).
- eigentlich [GNU R](http://www.r-project.org), ich nenne es aber einfach nur 
  **R**.
- ein Datenanalysetool zur Erstellung von Graphiken, Karten,
  Statistiken und Modellen.
- Der [Interpreter](https://de.wikipedia.org/wiki/Interpreter) f&uuml;r:
- eine [(interpretierte) Programmiersprache](https://en.wikipedia.org/wiki/Interpreted_language):
``` {r}
print("hello, world")

```

Der letzte Punkt ist meiner Meinung der wichtigste, denn: 

## Diese Einführung 
... soll Dir **R** als eine Programmiersprache nahebringen. 
Du wirst **R** hinterher nicht beherrschen. 
Aber vielleicht Lust bekommen haben, es n&auml;her kennenzulernen.

Nicht kennenlernen wirst Du in dieser Einführung **R** als Datenanalysetool,
insbesondere lernst Du hier nichts &uuml;ber **R** und Statistik. 
Allerdings will ich Dich ein wenig locken und verspreche Dir daher, dass Du 
[am Schlu&szlig;](#von-daten-zur-graphik) sch&ouml;ne Bilder machen kannst.

### Darstellung
Ich habe mich wenig um [HTML](https://en.wikipedia.org/wiki/HTML) und 
[CSS](https://en.wikipedia.org/wiki/Cascading_Style_Sheets) geschert, 
[Firefox](https://www.mozilla.org/en-US/firefox/new/) ergibt bei mir eine
bessere Darstellung als der Internet Explorer. Andere Browser habe ich unter
Windows nicht getestet.

###  **R**-Code und Output
Wie Du unter [bereits](#r-ist) gesehen hast, setze ich in diesem Dokument
Programmcode in leicht hinterlegten K&auml;sten, den interpretierten Output in
nicht hinterlegten  K&auml;sten mit zwei f&uuml;hrenden #. Wobei ich den Output
zuweilen, wo er mir l&auml;nglich oder nicht hilfreich erscheint,
unterdr&uuml;cke.
Ein hinterlegtes Textst&uuml;ck innerhalb einer normalen Textzeile zeigt an, 
dass das Textst&uuml;ck ebenfalls **R**-Code ist, dieser aber nicht dazu gedacht
ist, in der dargestellten Form von Dir ausgef&uuml;hrt zu werden. `print`
beispielsweise ist der Name einer Funktion, die wir [oben](#r)  bereits
benuzt haben, die Eingabe von `print` allein in **R** ist aber nicht sinnvoll, 
die von `print()` erzeugt sogar einen Fehler. 
Dennoch sind beides **R**-Code-St&uuml;cke, weswegen ich sie durch Hinterlegung
kennzeichne.

Da dieses Dokument in 
[rmarkdown](https://cran.r-project.org/web/packages/rmarkdown) geschrieben ist
(Details findest Du [hinten](#dieses-dokument)),
wird der Output tats&auml;chlich durch den **R**-Code erzeugt. 
Den gesamten **R**-Code in diesem Dokument findest Du [hier](index.R), einzelne 
Teile aber auch in [diesen **R**-Codes](src).

### Aufgaben
Du findest eine Reihe von Aufgaben in den ersten vier Kapiteln dieses Dokuments.
Sie sehen so aus:

<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Schreibe Code, der
``` {r, echo = FALSE}
source("answers/example.r")
``` 
ausgibt.   

[Hier findest Du meine L&ouml;sung.](answers/example.r)
</div>
Versuche, sie zu l&ouml;sen, vergleiche dann Deinen Versuch mit meiner
L&ouml;sung (und schreibe mir, falls Dir Dein Versuch eleganter,
sch&ouml;ner oder verst&auml;ndlicher als meine L&ouml;sung erscheint) und lies
_erst dann_ weiter.


# Grundlagen

## **R** benutzen
Um **R** zu nutzen, brauchst Du einen Interpreter. Den kannst Du &uuml;ber die 
Softwareverteilung des Benutzerservice installieren - wahrscheinlich nach
C:\\Program Files\\R\\R-3.1.2\\bin\\i386 oder so.
In diesem Verzeichnis findest Du R.exe, einen 
[command line interpreter](https://en.wikipedia.org/wiki/List_of_command-line_interpreters) 
und Rgui.exe, eine graphische Nutzeroberfl&auml;che f&uuml;r R.exe. 
In beiden kannst Du **R**-Code schreiben, Rgui.exe bietet Dir rudiment&auml;re
Editor-Funktionen, R.exe nicht.

Beide sind nicht sehr komfortabel, daher benutzen Viele an der FVA 
hauptsächlich [RStudio](https://www.rstudio.com/), eine
[IDE](https://en.wikipedia.org/wiki/Integrated_development_environment), mit 
der Du Code editieren und an den **R**-Interpreter &uuml;bergeben kannst.
Du kannst RStudio ebenfalls &uuml;ber die Softwareverteilung des 
Benutzerservice installieren. 
Aber auch andere Entwicklungsumgebungen oder Editoren sind gut. 


``` {r, echo = FALSE}
## I turn off help. Restore it via
#  options(list(pager = file.path(R.home(), "bin/pager")))
options(list(pager = function(..., header,
                     title = "R Information",
               delete.file = FALSE){
               return(NULL)
               }
               )
               )
``` 
<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Ver&auml;ndere den [obigen Code](#r) so, dass er 
``` {r, echo = FALSE}
source("answers/hello.r")
``` 
ausgibt.   

[Hier findest Du meine L&ouml;sung.](answers/hello.r)
</div>

### **R** im Batch benutzen
Es gibt auch noch die M&ouml;glichkeit, **R** nicht interaktiv sondern im 
Batch-Modus zu nutzen. Das sehen wir aber erst [sp&auml;ter](#r-im-batch).

## Hilfe finden mit der Hilfefunktion
Die Hilfefunktion h&ouml;rt auf den Namen `help()`, sie hat auch eine Kurzform:
``` {r}
help("help", package = "utils")
?help
``` 
Sie liefert eine Hilfeseite die, je nach Konfiguration Deiner Arbeitsumgebung
und Optionen f&uuml;r die Hilfefunktion, als Text, html oder pdf erscheint. 
Sie kann beispielswiese 
[so](files/r_help.html)
aussehen.
Ich finde die Hinweise in der Rubrik ``See Also:`` oft hilfreich.
Ein gutes Beispiel ist 
``` {r}
help("Syntax", package = "base")
?Syntax
``` 
Hier findest Du eine sehr technische Einf&uuml;hrung in die Syntax von **R** und
Verweise auf (unter anderen) die wichtigen Hilfeseiten 
`help("Comparison", package = "base")`
und
`help("Logic", package = "base")`
, auf denen die Vergleichsoperatoren und die logischen Operatoren beschrieben
werden.

## Zuweisungen
Alle Objekte ([Daten](#datentypen-und-indizierung) und 
[Funktionen](#funktionen))
in **R** werden durch Zuweisungen definiert.
``` {r}
a_number <- 3
``` 
Das ist schon recht technisch, denn in anderen Sprachen werden Objekte
zun&auml;chst definiert (oder zumindest deklariert) und erst dann wird ihnen ein
Wert zugewiesen. Das ist etwas umst&auml;ndlich, aber daf&uuml;r funktioniert
der folgende Code in **R** leider:
``` {r}
a_number <- "this is no number, it's a string!"
``` 
Ich kann also ein Objekt mit einem Objekt eines anderen Typs &uuml;berschreiben.


<!---_(Manche Programmiersprachen verlangen die Deklaration eines
Objektes (mit einem bestimmten Typ), in **R** erfolgt die Deklaration und die
Typbestimmung automatisch aus der ersten Zuweisung.)_
-->

Wie bei der Hilfe gibt es neben der Kurzform (bzw. den 5 verschiedenen
Kurzformen, Genaueres findest Du mit `help("assignOps", package = "base")`)
eine flexiblere, ausf&uuml;hrlichere Variante, die ich aber in "normalen"
**R**-Skripten fast nie verwende:
``` {r}
assign("a_number", 4)
``` 
<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Weise dem Objekt `my_name` Deinen Namen zu und gebe den Wert des Objektes
aus. Bei mir sieht das Ergebnis dann so
``` {r, echo = FALSE}
source("answers/name.r")
``` 
aus. 

[Hier findest Du meine L&ouml;sung.](answers/name.r)
</div>

## Funktionen 
Funktionen spielen in **R** eine gro&szlig;e Rolle, weitaus die meisten
[Anweisungen](https://de.wikipedia.org/wiki/Anweisung_%28Programmierung%29) in
**R** sind Funktionsaufrufe. 

<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Die **R**-Funktion `readline()` liest eine Eingabe vom **R**-Prompt.
Lies Dir ihre Hilfeseite durch und schreibe ein Programm, das mich auffordert, 
Deinen Namen zu raten und meine Eingabe einem Objekt des Namens `guess` zuweist.
Dann soll es meine Eingabe drucken.

[Hier findest Du meine L&ouml;sung.](answers/readline.r)
</div>



Eine Liste der in Deiner Umgebung verf&uuml;gbaren
Funktionen erh&auml;ltst Du durch
``` {r, results = "hide"}
for (pos in seq(along = searchpaths())) {
    print(lsf.str(pos))
}
```

Allerdings h&auml;ngt diese Liste von den gerade geladenen [Pakete](#r-packages)
ab.

## Operatoren
Wenn wir zwei Dinge miteinander vergleichen wollen, nutzen wir die
Vergleichsoperatoren, die wir gerade schon durch 
`help("Comparison", package = "base")` kennengelernt haben:
``` {r}
a_number != 4 
``` 
*Es gibt in **R** die Funktionen `identical()` und `all.equal()`, die,
wie `==` auf Gleichheit testen. 
Die Hilfeseite `?Comparison` empfiehlt `identical` (beziehungsweise `!
identical`) f&uuml;r Tests in Kontrollstrukturen. 
Um zu testen, ob zwei Zahlen gleich sind, empfiehlt sie
`identical(all.equal(n1, n2), TRUE)` 
oder die Kurzform 
`isTRUE(all.equal(n1, n2))`. 
*

Vergleiche (aber auch andere **R**-Anweisungen) k&ouml;nnen wir durch logische
Operatoren, 
die wir gerade schon durch `help("Logic", package = "base")` kennengelernt 
haben,
verkn&uuml;pfen:
``` {r}
a_number != 4 || a_number == 4
``` 

<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Die **R**-Funktion `readline()` liest eine Eingabe vom **R**-Prompt.
Lies Dir ihre Hilfeseite durch und schreibe ein Programm, das mich auffordert, 
Deinen Namen zu raten und meine Eingabe einem Objekt des Namens `guess` zuweist.
Weise dem Objekt `my_name` Deinen Namen und la&szlig; Dein Programm
pr&uuml;fen, ob ich richtig geraten habe.

[Hier findest Du meine L&ouml;sung.](answers/readline_test.r)
</div>

## **R**-Packages
**R** ist in Packages, also Paketen, organisiert. 
Es gibt verschieden Stufen dieser Pakete:

1. Pakete, die zum Kern, **R**-base genannt, geh&ouml;ren, sie werden mit **R**
   installiert.
1. Empfohlene Pakete, **R**-recommended genannt. Sie werden auf den 
   **R**-Servern verwaltet und sind vorwiegend sehr guter Qualtit&auml;t.
   Je nach Betriebssystem werden sie gleich mitinstalliert, sonst 
   kannst Du sie, bei funktionierender Internetverbindung, mit der Funktion
   `install.packages` installieren und mit der Funktion `library` laden.
1. Von Nutzern beigesteuerte Pakete, **R**-contributed genannt. Sie werden
   ebenfalls auf den **R**-Servern verwaltet und sind sehr unterschiedlicher
   Qualtit&auml;t. Es gibt 
   [mehrere Tausend](https://cran.r-project.org/web/packages/index.html) von 
   ihnen.
   Ihre Verwaltung ist identisch zu der der empfohlenen Pakete.  
   Ein wenig Ordnung ins Chaos zu bringen versuchen die 
   [**R** Task Views](https://cran.r-project.org/web/views/), eine Art 
   kommentierte Linkliste, die von Freiwilligen gepflegt wird.
1. "Wilde" **R**-Pakete. Das Netz ist voll davon: auf 
   [github](https://github.com), [r-forge](https://r-forge.r-project.org/), 
   [bioconductor](https://www.bioconductor.org/) und etlichen privaten Sites. 
   La&szlig;' vorerst besser die Finger von ihnen. 

# Kontrollstrukturen
Da **R** eine Programmiersprache ist, sehen wir uns zun&auml;chst ein paar
klassische Dinge an, die jede Programmiersprache k&ouml;nnen sollte.
Hilfe dazu erh&auml;ltst Du durch `help("Control", package = "base")`.


## Bedingte Anweisungen
Ich benutze haupts&auml;chlich das gew&ouml;hnliche If-else, habe aber der
Vollst&auml;ndigkeit halber noch zwei weitere bedingte Anweisungen
aufgef&uuml;hrt. 
Lies im Zweifelsfall nur den ersten Abschnitt.

### If-else
... pr&uuml;ft eine Kondition und f&uuml;hrt, abh&auml;ngig vom Ausgang der
Pr&uuml;fung, den konsekutiven Codeblock oder einen alternativen Codeblock aus:
``` {r}
condition <- a_number <= 3
if (condition) {
  print("Consecution")
} else {
  print("Alternative")
}
``` 
<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Die **R**-Funktion `readline()` liest eine Eingabe vom **R**-Prompt.
Lies Dir ihre Hilfeseite durch und schreibe ein Programm, das mich auffordert, 
Deinen Namen zu raten und meine Eingabe einem Objekt des Namens `guess` zuweist.
Den Wert dieses Objektes soll es dann mit Deinem Namen vergleichen und, je nach
Ergebnis, entweder *You win!* oder *You loose!* ausgeben.

[Hier findest Du meine L&ouml;sung.](answers/guess_my_name.r)
</div>

### `ifelse()`
Es gibt eine weitere  Version dieser Answeisung, die Funktion `ifelse()`.
Sie arbeitet mit Vektoren:
``` {r}
randomly_true <- sample(x = c(TRUE, FALSE), size = 10, replace = TRUE)
print(randomly_true)
ifelse(randomly_true, "Consecution", "Alternative")
``` 
`randomly_true` is bei jeder Ausf&uuml;hrung pontentiell anders.

Um eine Zufallsziehung reproduzierbar - also ``nicht`` zuf&auml;llig - zu 
machen, nutze ich etwas wie:
``` {r, eval = FALSE}
set.seed(456432346)
not_randomly_true <- sample(x = c(TRUE, FALSE), size = 10, replace = TRUE)
print(not_randomly_true)
``` 
### `switch()`
... ist eine _Funktion_, die aus einer Liste das passende Element ausgibt:
``` {r}
abbreviation <- "sALN"
switch(abbreviation, 
       FI = "Fichte",
       TA = "Tanne",   
       DGL = "Douglasie", 
       KIE = "Kiefer",  
       LAE = "Lärchen", 
       sNB = "sonst. Nadelholz",
       BU = "Buche",
       EI = "Eichen",
       REI = "Roteiche",
       ES = "Esche",
       BA = "Bergahorn",
       HB = "Hainbuche",
       sALH = "sonst. Hartholz",
       BI = "Birken",
       ER = "Erlen",
       PA = "Pappeln",
       sALN = "sonst. Weichholz",
       stop("Got unkown abbreviation \"", abbreviation, "\"!")
       )



``` 
Es kann aber komplizierter werden, denn `switch()` f&uuml;hrt auch 
Codebl&ouml;cke aus:
``` {r}
my_number <- NULL
switch(2,
       my_number <- 1,
       {
           my_number <- 3
           message("This doesn't make any sense. It's just an example.")
       },
       stop("works only for 1 or 2")
       )
a_number * my_number



``` 
Das sollten wir allerdings vielleicht doch besser lassen. Denn der Code wird
zur&uuml;ckgeben und ausgef&uuml;hrt, das hei&szlig;t: er &uuml;berschreibt
eventuelle Zuweisungen im "Mutterprogramm". Das sollten Funktionen eigentlich
nicht tun. 
Allerdings ist `switch()` (in manchen Sprachen auch `case`
genannt) in anderen Programmiersprachen auch keine Funktion, sondern, wie
Schleifen und `if`, ein Sprachkonstrukt, in **R** hingegen ist fast alles eine
Funktion...

## Schleifen 
... f&uuml;hren Code wiederholt aus. Es gibt gute Schleifen und schlechte
Schleifen und, eine Besonderheit in **R**, `apply()`s.
Ich nutze in **R** fast nur die `for`-Schleife und die `while`-Schleife.
Lies im Zweifelsfall nur den ersten Abschnitt.

### Gute Schleifen
Die `for`-Schleife wiederholt ihren Code eine bestimmte Anzahl an 
Durchg&auml;ngen:
``` {r}
indices <- c(1, 2, 3)
for (index in indices) {
    print(index)
}
``` 
Um zu verstehen, was hier passiert 
*- und nur dazu, es gibt in **R** die Funktion `sum()`, die Du verwenden
solltest, um Vektorelemente zu summieren! -*, 
nehmen wir mal das Summenzeichen aus der Mathematik: 
<math> <mstyle displaystyle="true"><mo>&sum;</mo></mstyle> </math>.

Nehmen wir an, da&szlig; 
<math> <mstyle displaystyle="true"> <mi>n</mi> <mo>=</mo> <mn>3</mn> </mstyle>
</math>
sei, dann ist 
<math> <mstyle displaystyle="true"> 
<munderover> <mo>&sum;</mo> 
<mrow><mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> 
<mi>n</mi> </munderover>
<mfenced separators=""><mi>i</mi><mo>-</mo> <mn>1</mn> </mfenced>
<mo>=</mo> <mn>3</mn>
</mstyle> </math>.
Das Summenzeichen ist ein Speziallfall einer Schleife, wir k&ouml;nnen es in
**R** nachbauen:
``` {r}
value <- 0
n <- 3
for (i in seq(1, n)) {
    value <- value + i - 1
}
print(value)


``` 
`for` verh&auml;lt sich wie 
<math> <mstyle displaystyle="true"><mo>&sum;</mo></mstyle> </math>: in der
runden Klammer nach `for` schreiben wir das "i gleich 1 bis n" auf, in der
geschweiften das, was in der runden Klammer nach dem Summenzeichen kommt.
Dazu brauchen wir allerdings ein Object, hier `value`, dem wir die
Werte von i zuaddieren k&ouml;nnen. 
Da 0 neutral zur Addition ist, bef&uuml;llen wir `value` mit dem Wert 0.

Nehmen wir jetzt an, da&szlig;
<math> <mstyle displaystyle="true"> 
<mi>a</mi> <mo>=</mo> 
<mfenced><mn>2</mn><mn>3</mn><mn>4</mn><mn>10</mn></mfenced> 
</mstyle> </math>
sei, dann ist 
<math> <mstyle displaystyle="true">
<munderover> <mo>&sum;</mo> 
<mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>n</mi> </munderover>
<mfenced separators=""> <msub><mi>a</mi><mi>i</mi></msub><mo>-</mo> <mn>1</mn> 
</mfenced>
<mo>=</mo> <mn>6</mn> 
</mstyle> </math>
(<math> <mstyle displaystyle="true"> <mi>n</mi> </math> </mstyle> 
ist ja immer noch gleich 
<math> <mstyle displaystyle="true"> <mn>3</mn> </math> </mstyle> ).

Auch das ist eine Schleife:
``` {r}
a  <- c(2, 3, 4, 10)
value <- 0
n <- 3
for (i in seq(1, n)) {
    value <- value + a[i] - 1
}
print(value)


``` 
Die Indizierung von
<math> <mstyle displaystyle="true"> <mi>a</mi> </math> </mstyle> 
durch 
<math> <mstyle displaystyle="true"> <mi>i</mi> </math> </mstyle> 
ist von einer tiefgestellten Zahl in der mathematischen Notation zu einer Zahl
in eckigen Klammern in **R** geworden, der Rest war ja eher absehbar.
Indizierungen in **R** schauen wir uns 
[sp&auml;ter](#datentypen-und-indizierung) an.

Wenn Du die Schleife nicht nur bis zum dritten, sondern &uuml;ber alle Elemente
von 
<math> <mstyle displaystyle="true"> <mi>a</mi> </math> </mstyle> 
laufen lassen m&ouml;chtest (Entsprechendes will ich bei fast allen meiner
Schleifen), dann ist
``` {r}
a  <- c(2, 3, 4, 10)
value <- 0
for (i in seq(along = a)) {
    value <- value + a[i] - 1
}
print(value)


``` 
die am wenigsten fehleranf&auml;llige Variante.


Allgemein kannst Du das Verhalten einer Schleifen an diesem Code erkennen:

``` {r}
some_vector <- c("a", "b", "c")
for (index in seq(along = some_vector)) {
    cat("Element ", index, " contains ", some_vector[index], ".\n", sep = "")
}

``` 
Die `while`-Schleife wiederholt ihren Code, solange ihre Bedingung wahr ist:
``` {r}
some_vector <- c("a", "b", "c")
index <- 1
while (index <= length(some_vector)) {
    cat("Element ", index, " contains ", some_vector[index], ".\n", sep = "")
    index <- index + 1
}

``` 
Beide Typen sind eng miteinander verwandt, fast jede `for`-Schleife
l&auml;&szlig;t sich als `while`-Schleife umschreiben. 
Ich nutze `for`-Schleifen, wenn es ein Objekt gibt, &uuml;ber dessen Elemente 
ich die Schleife laufen lassen m&ouml;chte (und das ist meistens so, da in **R**
ja fast alles ein Objekt ist. Selbst Funktionen ...) - dann finde ich sie 
kompakter und dadurch weniger schreibfehleranf&auml;llig -, und sonst 
`while`-Schleifen. 

<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Ver&auml;ndere Dein Namen-raten-Programm so, dass es solange fragt, bis ich
Deinen Namen rate.

[Hier findest Du meine L&ouml;sung.](answers/guess_my_name_loop.r)
</div>

### `apply()`-"Schleifen"
Es gibt in **R** die Tradition, vektorwertig zu programmieren. 
Vektorwertiger Code l&auml;uft in **R** meist schneller, 
er nutzt die Familie der `apply()`-Funktionen. 
F&uuml;r mich ist er aber deutlich schwerer zu schreiben und zu verstehen. 
Obige Schleifen siehst Du hier vektorwertig reimplementiert:
``` {r}
some_vector <- c("a", "b", "c")
invisible(vapply(some_vector, 
       function(x) {
           cat("An Element contains ", x, ".\n", sep = "")
           return(unlist(x))
       },
       character(1)
       )
)


``` 
Ich musste  eine [Funktion](Funktionen) einbauen und ich verliere die 
Information &uuml;ber
den Index. Vielleicht sollte ich in einer Einf&uuml;hrung vektorwertiges
Programmieren nicht erw&auml;hnen, aber dann findest Du irgendwo im Netz die
Ausssage, das es viel besser und schneller sei als Schleifen. Schneller? Stimmt
meist.
Besser? Finde ich nicht. Falls Du Schleifen besser verstehst: programmiere
Schleifen.
Die Funktion `apply()` selbst ist in **R** geschrieben
und f&uuml;hrt in ihrem Kern ([den Zeilen 39 bis 53](src/apply.r)) eine
`for`-Schleife aus.
Du kannst eine **R**-Funktionen betrachten, indem Du einfach ihren Namen ohne
anschliessende Klammern aufruft (ich unterdr&uuml;cke hier den output, der ist
l&auml;nglich):
``` {r, results = "hide"}
apply
```
Komfortabler wird's so<a name="tempfile"></a>:
``` {r, results = "hide"}
temporary_file <- tempfile()
connection <- file(temporary_file)
writeLines(capture.output(apply), connection)
close(connection)
file.show(temporary_file)


```

### Schlechte Schleifen
Es gibt in **R** (`help("Control", package = "base")` verr&auml;t es Dir) noch 
eine Schleifenart: Die **repeat**-Schleife f&uuml;hrt ihre Anweisungen einfach 
immer weiter aus. 
Bis Du sie mit einem  `break` beendest. Das ist Quatsch, das geht
auch immer mit einer **while**-Schleife und f&uuml;hrt nur dazu, dass Du Dir
`break` angew&ouml;hnst, was Du tunlichst unterlassen solltest. Ebenfalls
unterlassen solltest Du `next` (das Du eventuell aus anderen Programmiersprachen
als _continue_ kennst). 
Am besten vergisst Du einfach, dass es in **R** `repeat`, `break` und `next`
gibt.
Dennoch hier ein Beispiel: das Programm spielt das Namen-raten-Spiel bis
entweder ich den richtigen Namen geraten habe oder ich die Anzahl der
m&ouml;glichen Versuche verbraucht habe.
``` {r, eval = FALSE}
my_name  <- "Dominik Cullmann"
max_tries <- 3

guess <- readline(prompt = "Guess my name: ")
num_tries <- 1
repeat {
    if (num_tries > max_tries) {
        print("Did I forget to tell you that you only had three tries?")
        break
    } else {
        num_tries <- num_tries + 1
    }
    if (guess == my_name) {
        print("You win!")
        break
    } else {
        print("You loose!")
        guess <- readline(prompt = "Try again: ")
    }
}


```
<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Ver&auml;ndere Dein Namen-raten-Programm so, dass es das Gleiche kann wie
die `repeat`-Version, blo&szlig; mit `while`.

[Hier findest Du meine L&ouml;sung.](answers/guess_my_name_loop_control.r)

Beachte, dass ich in meiner L&ouml;sung nur eine Schleife und ein `if`, in der
`repeat`-Version aber eine Schleife, zwei `if` und zwei `break` ben&ouml;tige.
</div>





# **R** und das Dateisystem
Wie Du vielleicht [gerade schon](#tempfile) bemerkt hast, hat **R** eine 
(tempor&auml;re) Datei auf der Festplatte Deines Rechners erstellt. 
Da **R** eine Programmiersprache ist, kann sie mit Deinem Rechner interagieren.

Die Dateisystem-Funktion, die ich am h&auml;ufigsten nutze, `source()`, hat
ein Gegenst&uuml;ck, `sink()`.

``` {r, results = "hide"}
?source
?sink
``` 

`source()` liest eine Datei und interpretiert ihren Inhalt als **R**-Code. 
Ich nutze das oft, indem ich vielzeilige **R**-Code-Dateien in mehrere,
k&uuml;rzere zerteile
und sie dann in einer Steuerdatei nacheinander einlese.
Ich kann den in [diesen **R**-Codes](src/) gespeicherten Code des "hello,
world"-Beispiels nochmal lesen und interpretieren lassen:
``` {r}
file <- "src/hello_world.r"
if (file.exists(file)) {
    source(file)
} else {
    warning("You don't have ", file, " at hand!\n", 
            "This will crash!")
}


``` 

_(Genaugenommen habe ich das [oben](#r-ist) schon getan, nur nicht mit **R** und 
`source()`, sondern mit 
[einen Pr&auml;prozessor](http://www.math.polytechnique.fr/cmat/auroux/prog/gpp.html)
und einer ``include``-Anweisung, die f&uuml;r den Pr&auml;prozessor in etwa das
selbe gedeutet wie `source()` f&uuml;r **R**. Das kannst Du sehen, wenn Du Dir 
[dieses markdown-Dokument](index.rmd) anschaust. Warum ich das mit dem
Pr&auml;prozessor mache? Damit Du [oben](#r-ist) nicht die `source()`-Anweisung 
sondern den ge`source()`ten **R**-Code siehst.  
**Warum erkl&auml;re ich das?** Weil Du, wenn Du einfach den 
[gesamten **R**-Code dieser Seite](index.R) von **R** interpretieren l&auml;sst, 
auf eine Warnung stossen wirst - wenn **R** bei diesem Beispiel versucht, 
die Datei *src/hello_world.r* zu `source()`en und sie nicht findet.
Es sei denn, Du hast Dir das Verzeichnis src/ samt Inhalt in Dein aktuelles
**R**-Arbeitsverzeichnis kopiert...)_

`sink()` leitet (fast) den gesamten Output von **R** in eine Datei um:
``` {r}
temporary_file <- tempfile()
{   # you don't need the braces in common R code, but I use rmarkdown::render()
    #  (which uses knitr::knit() which uses sink() to capture results. See 
    #   https://groups.google.com/forum/#!topic/knitr/TCz9vNLlslY) 
    # to parse an R/markdown file into this html file. 
    # So I need the braces here. 
    sink(temporary_file)
    directory <- "./src/"
    warning("message()s, warning()s and stop()s are not sink()ed.")
    cat("I use cat() instead of print() here to get rid of the indeces",
        "print()ed.\n", sep = " ")
    cat("This is the directory listing of '", directory, "':", "\n", sep = "")
    cat(list.files(directory), sep = "\n")
    sink()
}


``` 
Das kann hilfreich sein, um Berechnungen dauerhaft zu speichern, 
diese html-Seite wird beispielsweise durch das **R**-Pagacke `knitr` gesetzt, 
indem es `sink()` einsetzt.

Nur um zu zeigen, dass es funktioniert, 
lese ich nun die Zeilen der Datei wieder ein, normalerweise ist das sinnlos:
``` {r}
readLines(temporary_file)
``` 

**R** kann auch Verzeichnisse erstellen und Dateien kopieren, umbennenen oder
l&ouml;schen:
``` {r, results = "hide"}
not_so_temporary_directory <- file.path(dirname(tempdir()) , "R_intro")
dir.create(not_so_temporary_directory, showWarnings = FALSE)


## Sometimes in April ...
not_so_temporary_file <- file.path(not_so_temporary_directory, "readme.md")
cat("My first readme file.", file = not_so_temporary_file, sep = "\n")

## ... some days later
if (file.exists(not_so_temporary_file)) {
    file.rename(not_so_temporary_file, paste0(not_so_temporary_file, "1"))
}
cat("This is a directory created by 'Programmieren in R' .",
    file = not_so_temporary_file, sep = "\n")



``` 
Du kannst das `not_so_temporary_directory` gerne andernorts anlegen,
ich bin mir nur sicher, dass Du auf dem Rechner vor Dir unterhalb von
`dirname(tempdir())` Schreibrechte hast.
Mit

``` {r}
?files
``` 
erh&auml;ltst Du eine erste &Uuml;bersicht. Zu `dirname()` gibt es auch noch
``` {r}
?basename
``` 
das Dir den Dateinamen eines Pfades zur&uuml;ckgibt.
<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Schreibe ein Programm, dass Dir den [den "hello, world"-Code](src/hello_world.r)
in eine Datei schreibt.

[Hier findest Du meine L&ouml;sung.](answers/create_hello_world.r)
</div>

<div style="background-color:#98E2A9; border:3px #C4DCFB solid;">
**Beispiel:**
Stelle Dir vor, Du g&auml;best **R**-Kurse und m&ouml;chtest f&uuml;r die
Teilnehmenden pers&ouml;nliche Verzeichnisse erstellen. 
Die Namen der Teilnehmenden eines Kurstermines l&auml;gen Dir in der Datei
[files/names.txt](files/names.txt) vor.

Jetzt kannst Du entweder die Verzeichnisse (per copy & paste) von Hand
erstellen, oder Dir die M&uuml;he machen, das folgende **R**-Programm zu
entwickeln:
``` {r}
#% set the root directory and read the file containing the names
path <- file.path(dirname(tempdir()), "personal_directories")
lines <- readLines("files/names.txt")

#% extract names, order them in FIRSTNAME_LASTNAME
non_empty_lines <- lines[which(lines != "")]
tmp <- sub("^ *", "", non_empty_lines)
names <- sub(" *", "", tmp)
last_names <- sapply(strsplit(names, ","), "[", 1)
first_names <-  gsub(" ", "_", 
                     sub(" *$", "", 
                         sub("^ *", "", 
                             sapply(strsplit(names, ","), "[", 2)
                                   )
                         )
)
directories <- paste(first_names, last_names, sep = "_")
#% create path 
dir.create(path, showWarnings = FALSE, recursive = TRUE)
#% create those personal directories
for (directory in directories) {
    directory_path <- file.path(path, directory)
    dir.create(directory_path)
}


``` 
``` {r, echo = FALSE}
# need to get rid of the directory to avoid warnings -- for html only, usually,
# the warnings should be there.
unlink(file.path(dirname(tempdir()), "personal_directories"), recursive = TRUE)

``` 
Zugegeben, das dauert erstmal l&auml;nger. Aber nachdem auch die
Bundesau&szlig;en-, Bundesinnen- und Bundesverteidigungsminister und
-ministerinnen Deinen Kurs besucht haben, hast Du die Zeit allemal wieder raus.
</div>

## **R** im Batch
**R** unter Windows im Batchmodus zu nutzen erscheint mir wenig attraktiv, da
die [Windows Eingabeaufforderung](https://en.wikipedia.org/wiki/Cmd.exe) noch 
weniger kompfortabel ist als selbst Rgui.exe.
Dennoch zeige ich Dir kurz, dass Du eine **R**-Code-Datei auch 
- nunja: einfach? -
dem **R** Interpreter &uuml;bergeben kannst:
![R CMD BATCH unter Windows](./graphics/R_vanilla.jpg "R unter Windows")
Falls Du den gesamten Output in einer .Rout-Datei speichern willst, kannst Du 
R CMD BATCH nutzen:
![R CMD BATCH unter Windows](./graphics/R_CMD_BATCH.jpg "R CMD BATCH unter Windows")

Es gibt noch einen weiteren **R**-Interpreter: Rscript.exe schreibt einen recht
schlanken Output:
![Rscript unter Windows](./graphics/Rscript.jpg "Rscript unter Windows")
Ich nutze Rscript oft, allerdings nicht unter Windows.

# Daten
Du kannst Dir die Daten [hier](data/input) herunterladen, oder sie durch 
folgendes Skript in das `input_directory`  laden. 
_Falls Du nicht auf die Dateien zugreifen kannst, 
k&ouml;nnte das an Deiner Version von **R** liegen, ich habe es mit der 32-bit
Version von **R** 3.2.2 erfolgreich getestet.
Du kannst Dir in jedem Fall mit dem Code 
[im Anhang](#baumarten-daten) die Daten erstellen._

Im Weiteren werde ich jedenfalls davon ausgehen, dass sie im `input_directory` 
liegen.
``` {r, results = "hide", warning = FALSE, message = FALSE}
probably_at_fva <- function() {
    at_fva <- grepl("FVAFR-PC",  Sys.info()["nodename"]) || 
    grepl("fvafr",  Sys.info()["nodename"]) ||
    "f060" == Sys.info()["nodename"]
    return(at_fva)
}
not_so_temporary_directory <- file.path(dirname(tempdir()) , "R_intro")
dir.create(not_so_temporary_directory, showWarnings = FALSE)
input_directory <- file.path(not_so_temporary_directory, "data", "input")
dir.create(input_directory, recursive = TRUE)
dependencies <- c("XML", "RCurl", "httr")
for (dependency in dependencies) {
    if (! require(dependency, character.only = TRUE)) {
        install.packages(dependency, repos =  "http://ftp5.gwdg.de/pub/misc/cran/")
    }
    library(dependency, character.only = TRUE)
}
input_url <- "http://fvafrcu.github.io/programmieren_in_r/data/input/"
if (probably_at_fva()) {
    if (Sys.getenv("http_proxy") == "") {
        old_proxy <- Sys.getenv("http_proxy")
        Sys.setenv("http_proxy" = "10.127.255.17:8080")
    }
}
content <- getURLContent(input_url, verbose = TRUE)
hrefs <- grep("/", 
              grep("href", 
                   strsplit(as.character(content), "<")[[1]]
                   , value = TRUE
                   )
              , value = TRUE, invert = TRUE
              )
files  <- sapply( strsplit(hrefs, "\\\"") ,"[[", 2)  
for (file in files) {
    file_url <- file.path(input_url, file)
    file_path <- file.path(input_directory, file)
    if (Sys.info()["sysname"] == "Windows") {
        download.file(file_url, file_path, method = "wininet", mode = "wb")  
    } else {
        download.file(file_url, file_path, method = "curl")  
    }
}
if (probably_at_fva()) {
    if (Sys.getenv("http_proxy") == "") {
        Sys.setenv("http_proxy" = old_proxy)
    }
}



``` 
## Daten lesen und schreiben

### Textdateien

Um Dateien mit [Comma separated
values](https://de.wikipedia.org/wiki/CSV_%28Dateiformat%29) zu lesen und zu
schreiben, nutze ich vor allem die beiden Funktionen `read.csv2()` und
`write.csv2()`. 
``` {r}
species_shares_1987 <- read.csv2(file.path(input_directory, 
                                           "species_shares_1987.csv"))
species_shares_2002 <- read.csv2(file.path(input_directory, 
                                           "species_shares_2002.csv"))
species_shares_2012 <- read.csv2(file.path(input_directory, 
                                           "species_shares_2012.csv"))



```
<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
Im Gegensatz zu `<-` kann ich `assign` leicht in Schleifen nutzen, um
Objektnamen im Schleifendurchlauf zu erzeugen:
``` {r}
for (index in 1:3) {
    name <- paste0("v_", index)
    assign(name, index)
}
ls(pattern = "v_.")
print(v_2)
```
Schreibe die obigen drei Daten-Import-Anweisungen mit Hilfe einer Schleife.
[Hier findest Du meine L&ouml;sung.](answers/csv_input.r)
</div>

<div style="background-color:#FFE9E9; border:3px #C4DCFB solid;">
**Aufgabe:**
`list.files` zeigt die Dateien in einem Verzeichnis an, es kennt das Argument
`pattern = `, mit dem Du die Dateien filtern kannst:
``` {r, echo = TRUE}
list.files(path = "./src")
list.files(path = "./src", pattern = "^s.*\\.r$")
``` 
Die zweite Version filtern auf alle Dateinamen, die mit "s" anfangen (^s), dann 
beliebige Zeichen haben (.*) und auf ".r" enden (\\.r$).)

Schreibe Deine Schleife aus der letzten Aufgabe so um, dass Du Dateinamen mit
`list.files` ermittelst. 
[Hier findest Du meine L&ouml;sung.](answers/csv_input_pattern.r)

Jetzt stelle Dir vor, es w&auml;ren nicht nur die
Jahre 1987, 2002 und 2012, sondern alle Jahre seit 1960, f&uuml;r die Du eine
csv-Datei einlesen wolltest. 
</div>

### Microsoft-Access-Datenbanken
Die selben Daten kann ich auch aus Tabellen in einer Microsoft-Access-Datenbank
lesen:
``` {r, echo = FALSE}
if (.Platform$OS.type == "windows") {
if (! require("RODBC")) install.packages("RODBC")
library("RODBC")
channel <- odbcConnectAccess2007(file.path(input_directory, 
                                           "species_shares.accdb"))
species_shares_1987 <- sqlFetch(channel, "Species_shares_1987")
species_shares_2002 <- sqlFetch(channel, "Species_shares_2002")
species_shares_2012 <- sqlFetch(channel, "Species_shares_2012")
odbcClose(channel)

}
``` 
``` {r, eval = FALSE}
if (! require("RODBC")) install.packages("RODBC")
library("RODBC")
channel <- odbcConnectAccess2007(file.path(input_directory, 
                                           "species_shares.accdb"))
species_shares_1987 <- sqlFetch(channel, "Species_shares_1987")
species_shares_2002 <- sqlFetch(channel, "Species_shares_2002")
species_shares_2012 <- sqlFetch(channel, "Species_shares_2012")
odbcClose(channel)

``` 

_Falls das nicht funktioniert, liegt das eventuell daran, dass Du **R** in
64bit nutzt. 
Erh&auml;ltst Du durch_
``` {r, echo = TRUE, results = "hide"}
R.version["arch"]
``` 
_**arch x86_64**, so l&auml;uft **R** in 64bit, erh&auml;ltst Du **arch i386**, 
so sind es 32bit.  
Falls Du 64bit nutzt: starte **R** in 32bit. Nutzt Du R.exe oder Rgui.exe,
dann starte einfach die 32bit-Version (wahrscheinlich unter  
C:\\Program Files\\R\\R-3.1.2\\bin\\i386 oder so). 
Benutzt Du RStudio, so kannst Du &uuml;ber das Men&uuml; 
**Tools/Global Options.../** unter **General** die **R Version:** einstellen._

Es gibt die Funktionen `sqlSave()` und `sqlUpdate()`, die ich nie benutze. Sie
schreiben Daten aus **R** in Tabellen einer Microsoft-Access-Datenbank. 


Allerdings ben&ouml;tige ich, um Microsoft-Access-Datenbanken lesen und
schreiben zu k&ouml;nnen, das **R**-Package RODBC, das ich separat 
installieren und mit dem Befehl `library("RODBC")` laden muss.

### Microsoft-Excel-Arbeitsmappen
Die selben Daten lassen sich auch aus Tabellen einer
Microsoft-Excel-Arbeitsmappe importieren:
``` {r, echo = FALSE}
if (.Platform$OS.type == "windows") {
if (! require("xlsx")) install.packages("xlsx")
library("xlsx")
xlsx_file <- file.path(input_directory, "species_shares.xlsx")
species_shares_1987 <- read.xlsx(xlsx_file, sheetName = "1987")
species_shares_2002 <- read.xlsx(xlsx_file, sheetName = "2002")
species_shares_2012 <- read.xlsx(xlsx_file, sheetName = "2012")

}
``` 
``` {r, eval = FALSE}
if (! require("xlsx")) install.packages("xlsx")
library("xlsx")
xlsx_file <- file.path(input_directory, "species_shares.xlsx")
species_shares_1987 <- read.xlsx(xlsx_file, sheetName = "1987")
species_shares_2002 <- read.xlsx(xlsx_file, sheetName = "2002")
species_shares_2012 <- read.xlsx(xlsx_file, sheetName = "2012")

``` 
Auch hier gibt es eine Funktion, `write.xlsx()`, die Daten aus **R** in Tabellen
einer Microsoft-Excel-Arbeitsmappe schreibt, und wieder ben&ouml;tige ich ein
**R**-Package, das mir diese Funktionen bereitstellt.

## Datentypen und Indizierung

### data.frames
Die Daten, die wir nun gerade (mit welcher Funktion auch immer) eingelesen
haben, besitzen einen Datentyp, der ihre Struktur bestimmt.

Wir erfahren mit der Anweisung <a name="dataframe_is_list"></a>
``` {r}
mode(species_shares_1987)
```
dass es sich bei `species_shares_1987` um ein Object des Typs `list` handelt.
``` {r}
class(species_shares_1987)
```
zeigt uns, dass `species_shares_1987` die Klasse `data.frame` besitzt. 
`data.frame`s sind die Datentypen, 
in denen Du wahrscheinlich den Gro&szlig;teil Deiner Daten speichern wirst. 
Da sie genau das sind, was wir uns so unter einer "Tabelle" vorstellen:
Zweidimensional, rechteckig (wenn auch nicht in jeder Zelle ein Wert stehen
muss), mit Spalten (die oft Merkmale repr&auml;sentieren) und Zeilen (in denen
dann die Werte oder Beobachtungen stehen):
``` {r}
print(species_shares_2002)
```
#### Numerischer Index
Die Hilfeseite zur Indizierung findest Du unter help("Extract").  
Die Zeilen und Spalten eines `data.frame`s kann ich &uuml;ber ihren numerischen
Index ansprechen, wobei die linke obere Zelle in Index [1,1], die rechte untere
Zelle den Index [nrow(data\_frame), ncol(data\_frame)] besitzt:
``` {r}
species_shares_2002[3, 2]
species_shares_2002[nrow(species_shares_1987), ncol(species_shares_1987)]
```
#### Namensindex
Ein `data.frame` besitzt f&uuml;r die Zeilen und Spalten immer auch Namen (die
Zeilennamen sind - so wir sie nicht explizit anders vergeben -  einfach der 
numerische Zeilenindex als string, also "2" stattt 2):
``` {r}
dimnames(species_shares_2002)
```
und wir k&ouml;nnen nun die Zellen des `data.frame`s auch &uuml;ber Namen 
``` {r}
species_shares_2002["3", "prediction"]
```
oder gemischt (numerischer und Namensindex) ansprechen
``` {r}
species_shares_2002[3, "error"]
```
Ich halte Namensindices f&uuml;r deutlich besser als numerische, da sich die 
Namen nicht &auml;ndern, falls ich die Reihenfolge der Elemente des Objektes 
&auml;ndere!

##### Zeilennamen
Wie wir gerade gesehen haben, kennt **R** f&uuml;r `data.frame`s nicht nur
Variablen- oder Spaltennamen sondern auch Zeilennamen. Wenn wir **R** bei der
Erzeugung eines `data.frame`s nicht explizit Zeilennamen angeben, erzeugt **R**
sie durch Nummerierung der Zeilen. Diese Namen sind allerdings selbst keine
Zahlen sondern Zeichenketten.
Wir k&ouml;nnen diese Namen mit der Funktion `rownames()` abfragen:
``` {r}
rownames(species_shares_2002)
``` 
aber auch setzen. In unseren Daten bieten sich die Baumartengruppenk&uuml;rzel
an:
``` {r}
rownames(species_shares_2002) <- species_shares_2002[, "species_group_label"]
``` 
Jetzt k&ouml;nnen wir die Namensindices auch sinnvoll auf Zeilen anwenden:
``` {r}
species_shares_2002["DGL", "prediction"]
```


#### Logischer Index
``` {r}
(random_logical_index <- sample(c(TRUE, FALSE), nrow(species_shares_2002),
replace = TRUE))
species_shares_2002[random_logical_index, "prediction"]
```
Einen logischen Index nutze ich oft, um Datenbereiche auszuw&auml;hlen, wie Du
gleich sehen wirst.

#### Bereiche

Wir k&ouml;nnen &uuml;ber die Indices auch Bereiche des `data.frame`s
ausschneiden:
``` {r}
species_shares_2002[3:6, c("prediction", "error")]
```
Wenn Du den Index in einer Dimension nicht angibst, gilt er als komplett `TRUE`:
``` {r}
species_shares_2002[3:6, ]
```
Einen logischen Index kann ich auch durch Operatorenanweisungen erstellen, 
um f&uuml;r mich interessante Datenbereiche ausschneiden.   
Wenn ich mich f&uuml;r alle Laubb&auml;ume mit 5 oder mehr
Anteilsprozenten oder 5% oder weniger relativem Fehler interessiere, und auf
jeden Fall auch f&uuml;r Douglasie, ... dann klappt das so:
``` {r}
logical_index <- species_shares_2002["grouping"] == "deciduous" &
  (species_shares_2002 ["prediction"] >= 5 | 
   species_shares_2002 ["error"] / species_shares_2002 ["prediction"] 
   <= 0.05 ) | 
  species_shares_2002["species_group_label"] == "DGL" 
species_shares_2002[logical_index, ]
```
(Beachte bitte, dass ich bei den logischen Operatoren die vektorwertigen Formen
`&` und `|` benutzen muss.)
Ich gebe zu, dass das ist nicht sehr komfortabel ist, daher gibt es die Funktion
`subset`:
``` {r}
subset(species_shares_2002, grouping == "deciduous" & 
       (prediction > 5 | error / prediction < 0.05) | 
       species_group_label == "DGL" )
```
Wenn wir Daten bedingt &auml;ndern wollen, brauchen wir meines Wissens
allerdings die komplizierte Form mit der Indizierung:
``` {r}
species_shares_2002[logical_index, "flag"]  <- TRUE
print(species_shares_2002)
```
Das ist &uuml;brigens ein Fall, den ich oft habe: 
ich will Fehlwerte - hier: `NA` -
durch etwas anderes ersetzen. Klappt so:
``` {r}
species_shares_2002[is.na(species_shares_2002["flag"]), "flag"]  <- FALSE
species_shares_2002
``` 

#### Weitere Formen
Es gibt noch eine weitere Art der Indizierung, die keine Bereiche zul&auml;sst
und das gew&auml;hlte Element vereinfacht (falls das m&ouml;glich ist - hier ist
es das nicht):
``` {r}
species_shares_2002[[3, 2]]
```

Wenn ich eine ganze Spalte eines `data.frame`s will, benutze ich sie
h&auml;ufiger als die '['-Form da sie "einfach nur die Werte"
zur&uuml;ckgibt: 
``` {r}
species_shares_2012["prediction"]
(v3 <- species_shares_2012[["prediction"]])
```
mit der ersten Form erhalten wir einen `data.frame`, mit der zweiten einen
[Vektor](#vectors).

Du wirst vielleicht oft die Form
``` {r}
species_shares_2012$prediction
```
sehen. Sie ist Kurzform und Spezialfall von `[[`, bietet aber, durch die 
partielle Namensvervollst&auml;ndigung, einige h&auml;ssliche Fallstricke (falls
Dich das wirklich interessiert, findest Du [hier ein Beispiel](src/dollar.r)). 
Au&szlig;erdem geht
``` {r, results = "hide"}
name  <- "prediction"
species_shares_2012[[name]]
```
wohingegen 
``` {r}
name  <- "prediction"
species_shares_2012$name
```
im `data.frame` `species_shares_2012` nach einer Spalte namens `name` sucht, 
diese nicht findet und daher `NULL` zur&uuml;ckgibt, aber keinen Fehler 
ausl&ouml;st. 
Falls das also nicht das war, was Du wolltest, sagt **R** Dir nicht einmal 
bescheid.

Gew&ouml;hne Dir die `$`-Form daher lieber erst gar nicht an.

### `list`s
Wie Du [vielleicht gemerkt hast](#dataframe_is_list), ist ein Object der Klasse
`data.frame`  ein Objekt des Typs `list`. Genaugenommen:
der Spezialfall, bei dem alle Elemente der `list` (die Spalten) die gleiche
L&auml;nge haben (daher bekommt der `data.frame` seine Zeilenanzahl, die Du mit
`nrow()` herausfindest).
`list`s selbst sind sehr allgemein und sehr flexibel, sie sind einfach Listen
aus ein oder mehreren Elementen, die selbst wiederum Objekte beliebigen
Datentypes (ja, auch wiederum `list`s und sogar Funktionen, die in **R**
eben auch Objekte - des Datentyps `function` - sind) sind.  Du solltest Dich
*vorerst* von `list`s fernhalten.

### `vector`s
`vector`s sind sehr einfache Datentypen, deren Elemente alle entweder numerisch
oder Buchstaben(reihen) sein m&uuml;ssen. Wir indizieren sie numerisch 
``` {r}
v3[c(1,3)]
```
oder, nachdem wir sie benamst haben, &uuml;ber ihre Namen:
``` {r}
names(v3) <- species_shares_2012[["species_group_label"]]
v3[c("FI", "DGL")]
```

Auch hier finde ich Namensindeces wieder robuster: stell' Dir vor, ich schiebe
das erste Element des `vector`s `v3` aus Versehen an dessen letzte Stelle:
``` {r}
v3 <- c(v3[2:length(v3)], v3[1])
``` 
Jetzt erhalte ich mit 
``` {r}
v3[c(1,3)]
v3[c("FI", "DGL")]
``` 
zwei unterschiedliche Ergebnisse. Bei der zweiten Variante erscheint es mir so,
als erhielte ich, wonach ich fragen wollte, bei der ersten nur, wonach ich
gefragt habe - was ich aber in Unkenntnis der Struktur von `v3` nicht wollte.

### `factor`s
Ein `factor` ist ein  Spezialfall eines `vector`s. Seine Elemente dienen der
Gruppierung (eines anderen `vector`s oder `data.frame`s) und sind numerisch,
enthalten aber  _levels_, die den Gruppierungsstufen verst&auml;ndliche Name
zuweisen. Unsere  Spalten `species_group_label` in den `data.frame`s sind
solche Spezialvektoren:
``` {r}
species_shares_1987[["species_group_label"]] 
mode(species_shares_1987[["species_group_label"]])
class(species_shares_1987[["species_group_label"]])
```

`factor`s k&ouml;nnen nutzlich sein, da viele **R**-Funktionen sie erkennen
und ihre Struktur ber&uuml;cksichtigen, aber ich stolpere oft &uuml;ber sie,
weil ich bei einem `vector` vergesse, dass er `factor` ist und dann erstaunt
bin, dass er sich im Zweifelsfall numerisch verh&auml;lt.  Falls Du Zahlen
bekommst, wo Du Worte erwartest, k&ouml;nnte ein `factor` dahinterstecken:
Wenn Du Daten mit `data.frame` erstellst, liest dieses die **R**-Option 
_stringsAsFactors_, deren Wert Du mit `getOption("stringsAsFactors")`
abfragen und mit `options(stringsAsFactors = FALSE)` &auml;ndern kannst.
Die meisten Funktionen zum Datenimport (z.B. `read.csv` und `read.xslx`) nutzen
`data.frame`!


## Mehr von mir zu Datentypen 
findest Du unter [hier](data_types.html).

# Funktionen
Funktionen in **R** selbst zu schreiben ist sehr einfach und oft hilfreich. 
Wenn Du anf&auml;ngst, einen Code-Block mehrfach zu kopieren, solltest Du aus 
ihm eine Funktion basteln 
(in Rstudio kannst Du markierte Codezeilen über die 
Menüs “Code”/“Extract Function” in eine Funktion umwandeln).
Erinnere Dich an das Beispiel mit den pers&ouml;nlichen Verzeichnissen: falls Du
&ouml;fter Dateien mit Namen von Teilnehmenden erhieltest, k&ouml;nntest Du den
Code des Beispiels immer kopieren und den Namen der Datei anpassen. Oder Du
k&ouml;nntest folgende Funktion schreiben:
``` {r}
create_personal_directories <- function(file) {
    #% set to path to write to
    path  <- file.path(dirname(tempdir()), "personal_directories")
    #% read the file containing the names
    lines <- readLines(file)
    #% extract names, order them in FIRSTNAME_LASTNAME
    non_empty_lines <- lines[which(lines != "")]
    tmp <- sub("^ *", "", non_empty_lines)
    names <- sub(" *", "", tmp)
    last_names <- sapply(strsplit(names, ","), "[", 1)
    first_names <-  gsub(" ", "_", 
                         sub(" *$", "", 
                             sub("^ *", "", 
                                 sapply(strsplit(names, ","), "[", 2)
                                 )
                             )
                         )
    directories <- paste(first_names, last_names, sep = "_")
    #% create path 
    dir.create(path, showWarnings = FALSE, recursive = TRUE)
    #% create those personal directories
    status <- logical(length(directories))
    for (i in seq(along = directories)) {
         directory  <- directories[i]
         directory_path <- file.path(path, directory)
         status[i] <- dir.create(directory_path)
    }
    return(invisible(status))
}


``` 
und sie dann mit 
``` {r}
create_personal_directories("files/names.txt")

``` 
``` {r, echo = FALSE}
# need to get rid of the directory to avoid warnings -- for html only, usually,
# the warnings should be there.
unlink(file.path(dirname(tempdir()), "personal_directories"), recursive = TRUE)

``` 
aufrufen. 
Falls Du findest, dass Du den Pfad, unter dem die Verzeichnisse angelegt werden
sollen, w&auml;hlen k&ouml;nnen m&ouml;chtest, kannst Du die Funktion um ein
Argument erweitern:
``` {r}
create_personal_directories <- function(file, 
                                        path = file.path(dirname(tempdir()), 
                                                         "personal_directories")
                                        ) {
    #% read the file containing the names
    lines <- readLines(file)
    #% extract names, order them in FIRSTNAME_LASTNAME
    non_empty_lines <- lines[which(lines != "")]
    tmp <- sub("^ *", "", non_empty_lines)
    names <- sub(" *", "", tmp)
    last_names <- sapply(strsplit(names, ","), "[", 1)
    first_names <-  gsub(" ", "_", 
                         sub(" *$", "", 
                             sub("^ *", "", 
                                 sapply(strsplit(names, ","), "[", 2)
                                 )
                             )
                         )
    directories <- paste(first_names, last_names, sep = "_")
    #% create path 
    dir.create(path, showWarnings = FALSE, recursive = TRUE)
    #% create those personal directories
    status <- logical(length(directories))
    for (i in seq(along = directories)) {
         directory  <- directories[i]
         directory_path <- file.path(path, directory)
         status[i] <- dir.create(directory_path)
    }
    return(invisible(status))
}


``` 

Das zweite Funktionsargument, `path`, kennt nun eine Voreinstellung, die Du beim
Funktionsaufruf &auml;ndern &uuml;berschreiben kannst:
``` {r}
create_personal_directories("files/names.txt", 
                            path = file.path(tempdir(), "personal_directories"))

``` 
``` {r, echo = FALSE}
# need to get rid of the directory to avoid warnings -- for html only, usually,
# the warnings should be there.
unlink(file.path(tempdir(), "personal_directories"), recursive = TRUE)

``` 


Zur&uuml;ck zu unseren Baumartenanteilen:
Im `data.frame` `species_shares_1987` enth&auml;lt die Spalte
`species_group_label` eine kryptische Abk&uuml;rzung. 
Ihre Werte k&ouml;nnen wir mit der [uns bekannten
switch-Anweisung](src/switch_abbreviation.r) verst&auml;ndlicher machen:
``` {r}
# we need to convert the factor's values to character!
(abbreviation <- as.character(species_shares_1987["1", "species_group_label"]))
(text  <- 
switch(abbreviation, 
       FI = "Fichte",
       TA = "Tanne",   
       DGL = "Douglasie", 
       KIE = "Kiefer",  
       LAE = "Lärchen", 
       sNB = "sonst. Nadelholz",
       BU = "Buche",
       EI = "Eichen",
       REI = "Roteiche",
       ES = "Esche",
       BA = "Bergahorn",
       HB = "Hainbuche",
       sALH = "sonst. Hartholz",
       BI = "Birken",
       ER = "Erlen",
       PA = "Pappeln",
       sALN = "sonst. Weichholz",
       stop("Got unkown abbreviation \"", abbreviation, "\"!")
       )


)

``` 
Da `species_shares_1987[["species_group_label"]]` ein [`factor`](#factors) ist,
kann ich nicht einfach das Element 
`species_shares_1987["1", "species_group_label"]` mit `text` &uuml;berschreiben,
letzteres ist ja nicht numerisch.  
Ich muss den entsprechenden Eintrag in den _levels_ von
`species_shares_1987[["species_group_label"]]` &auml;ndern: 
``` {r}
abbreviations <- levels(species_shares_1987[["species_group_label"]])
levels(species_shares_1987[["species_group_label"]])[abbreviations == abbreviation] <-
    text


``` 
Das Prozedere erscheint hinreichend kompliziert. Und das muss ich nun entweder
von Hand siebzehnmal kopieren und f&uuml;r jede Baumart anpassen, oder ich muss
um die letzten drei Code-Bl&ouml;cke eine Schleife basteln, aber dann werde ich
den Code in drei Wochen kaum noch verstehen. Da helfen Funktionen weiter.

Verstecken wir zuerst die `switch()`-Funktion in einer eignen, kleinen Funktion:
``` {r}
get_species_group_text <- function (abbreviation) {
    text <-  switch(abbreviation, 
                    FI = "Fichte",
                    TA = "Tanne",   
                    DGL = "Douglasie", 
                    KIE = "Kiefer",  
                    LAE = "Lärchen", 
                    sNB = "sonst. Nadelholz",
                    BU = "Buche",
                    EI = "Eichen",
                    REI = "Roteiche",
                    ES = "Esche",
                    BA = "Bergahorn",
                    HB = "Hainbuche",
                    sALH = "sonst. Hartholz",
                    BI = "Birken",
                    ER = "Erlen",
                    PA = "Pappeln",
                    sALN = "sonst. Weichholz",
                    abbreviation
                    )
    return(text)
}



``` 
Die Funktion ist ein reiner 
[Alias](https://en.wikipedia.org/wiki/Aliasing_%28computing%29), sie 
f&uuml;hrt ja ausschliesslich den `switch()` aus 
_(und streng genommen sollte es sie nicht geben.
Sie dient nur dazu, dass ich den `switch()` im folgenden `vapply()` nicht 
ausschreiben muss. Ich finde dadurch das `vapply()` immerhin ein wenig
verst&auml;ndlicher)_.

Nun definieren wir uns noch eine wrapper-Funktion um `vapply()`, die den Aufruf
des `switch()` in `get_species_group_text` versteckt:
``` {r}
get_species_group_factor <- function(x) {
    levels(x) <- vapply(levels(x), 
                        get_species_group_text,
                        character(length = 1)
                        )
    return(x)

}


``` 
_(In diesem Fall w&uuml;rde ich normalerweise statt des `vapply()` sicher  eine 
`for`-Schleife nehmen: der R&uuml;ckgabewert von levels() ist meist nicht 
besonders lang. 
Der Didaktik halber haben ich es anders gemacht.)_  
Klappt:
``` {r}
get_species_group_factor(species_shares_1987[["species_group_label"]])
```
Jetzt kann ich bequem drei alle "species\_group\_label"-Spalten ersetzen.
``` {r}
species_shares_1987[["species_group_label"]] <- 
    get_species_group_factor(species_shares_1987[["species_group_label"]])
species_shares_2002[["species_group_label"]] <- 
    get_species_group_factor(species_shares_2002[["species_group_label"]])
species_shares_2012[["species_group_label"]] <- 
    get_species_group_factor(species_shares_2012[["species_group_label"]])


```
Der ganze technische Kram ist in zwei Funktionen verschwunden, die sich hinter
den Aufrufen von `get_species_group_factor()` verstecken. Falls ich die
Funktionen richtig implementiert habe, interessieren mich ihre Details nur noch
wenig und ich bin froh, wenn ich nur noch die drei Funktionsaufrufe sehe.


# Von Daten zur Graphik
Ich habe Dir bunte Bildchen versprochen, nun sollst Du sie haben.
Wir werden uns aus den Baumarten-Daten Balkengraphiken erstellen. Da wir drei
`data.frame`s darstellen wollen, nutzen wir eine Funktion.
``` {r}
plot_species_shares <- function(df, error_bars = TRUE) {
    #% prepare data
    year <- strsplit(deparse(substitute(df)), "_")[[1]][[3]]
    ##% sort data by prediction
    sorted_data <- df[order(df[["prediction"]]), ]
    #% prepare plot
    ##% set up common colors
    greens <-  c("deciduous" = rgb(124, 252, 0, maxColorValue = 255), 
                 "conifers" = rgb(0, 100, 0, maxColorValue = 255))
    ##% set the limits of the abscissa
    x_width <-  5
    x_max  <- ceiling(max(sorted_data[["prediction"]]) / x_width) * x_width
    x_min  <- 0
    par(omi = c(0.65, 0.95, 0.75, 0.75), mai = c(0.3, 2.2, 0.35, 0), 
        mgp = c(5, 3, 0), las = 1)  
    #% create plot
    ##% plot deciduous
    deciduous <- sorted_data[["prediction"]]
    deciduous[which(sorted_data[["grouping"]] != "deciduous")] <- 0
    x1 <- barplot(deciduous, names.arg = FALSE, horiz = TRUE, border = NA, 
                  xlim = c(x_min, x_max), col = greens["deciduous"],
                  cex.names = 0.85, axes = FALSE)
    ##% plot conifers in different color
    conifers <- sorted_data[["prediction"]]
    conifers[which(sorted_data[["grouping"]] != "conifer")] <- 0
    x2 <- barplot(conifers, names.arg = FALSE, horiz = TRUE, border = NA, 
                  xlim = c(x_min, x_max), col = greens["conifers"],
                  cex.names = 0.85, axes = FALSE, add = TRUE)
    ##% add error bars
    if (error_bars) {
        error <- 1.96 * sqrt(df[["error"]])
        arrows(sorted_data[["prediction"]] - error, x1, 
               sorted_data[["prediction"]] + error, x1, 
               angle = 90, code = 3, length = 0.03)
        text(x_max, 22.5, "Fehlerbalken: 1.96 Standardabweichungen", adj = 1, 
             xpd = TRUE, cex = 0.65, font = 3)
    }
    ##% add title and note
    mtext(paste0(year, ": Baumartenflächen im Gesamtwald"),  3,  line = 1.3,  
          adj = 0,  cex = 1.2, 
          outer = TRUE)
    text(x_max, 21.5, "Alle Angaben in Prozent", adj = 1, xpd = TRUE,
         cex = 0.65, font = 3)
    ##% create ordinate labels
    for (i in 1:length(sorted_data[["species_group_label"]])) {
        if (sorted_data[[i, "grouping"]] %in% c("conifer")) {
            font_type <- 2 #"bold"
        } else {
            font_type <- 1 #"plain"
        }
        text(-9, x1[i], sorted_data[i, "species_group_label"], xpd = TRUE, 
             adj = 1, cex = 0.85, font = font_type)
        text(-3.5, x1[i], round(sorted_data[[i, "prediction"]], 1), xpd = TRUE, 
             adj = 1, cex = 0.85, font = font_type)
    }
    ##% create shading rectangles
    steps <- (x_max - x_min) / x_width
    for (i in (1:steps) - 1) {
        if (i %% 2 == 0) {
            rect(i * x_width, -0.5, (i + 1) * x_width, 28, 
                 col = rgb(191, 239, 255, 120, maxColorValue = 255), 
                 border = NA
                 )
        } else {
            rect(i * x_width, -0.5, (i + 1) * x_width, 28, 
                 col = rgb(191, 239, 255, 80, maxColorValue = 255), 
                 border = NA
                 )
        }
    }
    ##% create abscissa labels
    width <-  10
    x <- seq(from = x_min, to = x_max, by = width)
    mtext(x, at = x, 1, line = 0, cex = 0.8)
}




```
Diese Funktion ist kein gutes Beispiel einer Funktion. Sie hat zu viele Zeilen
und ist nicht allgemein gehalten, sondern auf eine sehr spezielle Art von
Baumarten-Daten-`data.frame`s angepa&szlig;t. 
Sie dient nur dazu, dass ich den Code nicht dreimal tippen muss. 
Und falls Du jetzt die Farbe f&uuml;r die Nadelbaum-Balken &auml;ndern willst, 
musst Du das nur an einer Stelle statt drei Stellen im Code tun. 
Ist einfach weniger fehleranf&auml;llig.  
Funktionieren tut sie so:
``` {r}

plot_species_shares(species_shares_1987)
plot_species_shares(species_shares_2002, error_bars = FALSE)
plot_species_shares(species_shares_2012)

```


# Hintan
## Dieses Dokument ...
ist in [rmarkdown](https://cran.r-project.org/web/packages/rmarkdown), einer 
Mischung aus **R** und [markdown](http://daringfireball.net/projects/markdown/) 
geschrieben. Genaugenommen besteht sie aus 
[diesem rmarkdown-Dokument](index.rmd) und [diesen **R**-Codes](src), die durch 
[einen Pr&auml;prozessor](http://www.math.polytechnique.fr/cmat/auroux/prog/gpp.html) 
in [dieses rmarkdown-Dokument](index.Rmd) gesetzt werden, das wiederum durch 
[knitr](https://github.com/yihui/knitr) und [pandoc](http://pandoc.org/) in die 
html-Seite verwandelt wird, die Du gerade liest. Alles klar?

##  Weiterlesen
Wir haben einen
[Programmierleitfaden](file://H:/FVA-Projekte/Methodenforum/programmierleitfaden/programmierleitfaden.pdf)
an der Forstlichen Versuchs- und Forschungsanstalt Baden-W&uuml;rttemberg,
den zu befolgen ich bei der Erstellung der Beispielcodes versucht habe. 
*Du solltest ihn Dir demn&auml;chst durchlesen.*
Au&szlig;er Regeln bietet er noch einige Tipps rund um **R**. 
Vor allem aber findest Du dort im Unterkapitel "Anleitungen" weitere Dokumente
zu **R**, die Dich jetzt vielleicht interessieren k&ouml;nnten. 

Falls Du obigen Link nicht &ouml;ffnen kannst, etwa weil Du ihn nicht mit dem 
Internetexplorer eines Standard-FVA-PC zu &ouml;ffnen versuchst (das liegt an 
den Passw&ouml;rtern auf der internen Homepage ...), findest Du
[hier](https://raw.githubusercontent.com/fvafrCU/programmierleitfaden/master/programmierleitfaden.ps)
eine Version in [PostScript](http://de.wikipedia.org/wiki/PostScript). Lade sie
herunter und konvertiere sie gegebenenfalls in pdf.

## Weiterschreiben 
Falls Du diese Einführung bis hierher gelesen hast, ist Dir sicher etwas
aufgefallen, von dem Du weisst, wie es besser geht. Bitte hilf mir, diese
Einführung zu verbessern: schreibe mir an dominik.cullmann@forst.bwl.de, was 
Dir an Verbesserungsw&uuml;rdigem aufgefallen ist.

# Anhang
## Baumarten-Daten
``` {r, eval = FALSE}
species_shares_1987 <-
    structure(list(species_group_label = structure(c(8L, 17L, 4L, 
                                                     10L, 11L, 16L, 3L, 5L, 13L,
                                                     7L, 1L, 9L, 14L, 2L, 6L, 
                                                     12L, 15L), 
                                                   .Label = c("BA", "BI", "BU", 
                                                              "DGL", "EI", "ER", 
                                                              "ES", "FI", "HB", 
                                                              "KIE", "LAE", 
                                                              "PA", "REI", 
                                                              "sALH", "sALN", 
                                                              "sNB", "TA"),
                                                   class = "factor"), 
                   prediction = c(43.4629284667027, 7.86415232656841, 
                                  2.26216297553824, 8.06265606914114, 
                                  1.98345551354271, 0.258119453661548, 
                                  18.6633590554827, 6.44221004707153, 
                                  0.35059803997222, 3.10977158731384, 
                                  1.97088355582993, 0.869602592792654, 
                                  1.42365460297862, 0.718482907631762, 
                                  0.830511613550428, 0.835781310286287,
                                  0.891669881935334), 
                   error = c(0.536743142764836, 0.262752386955493, 
                             0.129393158401086, 0.281028879558596, 
                             0.0957647501950789, 0.0400083812731542, 
                             0.389178612482042, 0.226936220859848, 
                             0.0488116148358875, 0.137538118708037, 
                             0.097771346923237, 0.0594793138895747, 
                             0.0904682635067747, 0.055752264926238, 
                             0.0736516611206084, 0.0868833933034175, 
                             0.0604548633623663), 
                   grouping = structure(c(1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 
                                          2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L), 
                                        .Label = c("conifer", "deciduous"), 
                                        class = "factor")
                   ), 
              .Names = c("species_group_label", "prediction", "error", 
                         "grouping"), 
              class = "data.frame", row.names = c(NA, -17L)
              )

species_shares_2002 <-
    structure(list(species_group_label = structure(c(8L, 17L, 4L, 10L, 11L, 16L,
                                                     3L, 5L, 13L, 7L, 1L, 9L, 
                                                     14L, 2L, 6L, 12L, 15L), 
                                                   .Label = c("BA", "BI", "BU",
                                                              "DGL", "EI", "ER",
                                                              "ES", "FI", "HB",
                                                              "KIE", "LAE", 
                                                              "PA", "REI", 
                                                              "sALH", "sALN", 
                                                              "sNB", "TA"),
                                                   class = "factor"), 
                   prediction = c(37.6541737569276, 7.7972024041839, 
                                  2.84416204823979, 6.50871828897042, 
                                  1.89646865974553, 0.445212707829209, 
                                  21.2065514011396, 6.91947701194286, 
                                  0.427773788150808, 4.21173366638045, 
                                  2.83784794317384, 1.18034501600187, 
                                  1.92995628756537, 0.837975958160955, 
                                  0.983188665990165, 0.705704472718757, 
                                  1.61350792287878),
                   error = c(0.516872726399891, 0.256407272426103, 
                             0.148641313940045, 0.24019309828729, 
                             0.0923020697386302, 0.0596218555415915, 
                             0.394877125787159, 0.231660735729548, 
                             0.0542174195188222, 0.161229780433931, 
                             0.122025049342518, 0.0719240232167699, 
                             0.105193197027116, 0.0620204258221561, 
                             0.0798713826799925, 0.0719370996103648, 
                             0.0886195995701987), 
                   grouping = structure(c(1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 
                                          2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L),
                                        .Label = c("conifer", "deciduous"),
                                        class = "factor")
                   ),
              .Names = c("species_group_label", "prediction", "error", 
                         "grouping"),
              class = "data.frame", row.names = c(NA, -17L)
              )


species_shares_2012 <-
    structure(list(species_group_label = structure(c(8L, 17L, 4L, 10L, 11L, 16L,
                                                     3L, 5L, 13L, 7L, 1L, 9L, 
                                                     14L, 2L, 6L, 12L, 15L),
                                                   .Label = c("BA", "BI", "BU", 
                                                              "DGL", "EI", "ER", 
                                                              "ES", "FI", "HB", 
                                                              "KIE", "LAE", 
                                                              "PA", "REI", 
                                                              "sALH", "sALN", 
                                                              "sNB", "TA"),
                                                   class = "factor"), 
                   prediction = c(33.9691456012294, 7.99971033422974, 
                                  3.37185094122167, 5.58481905493661, 
                                  1.76833653476758, 0.469877064925086, 
                                  21.8136258163657, 7.05250096043027, 
                                  0.538397233960815, 4.91372646945832,
                                  3.65022666154437, 1.43595082597003, 
                                  2.17737610449481, 1.24868228966577, 
                                  1.08279677295428, 0.724697656550135, 
                                  2.19827967729543),
                   error = c(0.497512506586033, 0.253156122081137, 
                             0.157245423563603, 0.218553145335019, 
                             0.0865678202466183, 0.0572587889177698,
                             0.392239679332439, 0.226761402556839, 
                             0.059160429882746, 0.169849882166813, 
                             0.137906630574863, 0.0806802789826653, 
                             0.109612521393389, 0.0805661157918473, 
                             0.0852946611195881, 0.0765991333570295, 
                             0.104578534434981),
                   grouping = structure(c(1L, 1L, 1L, 1L, 
                                          1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 
                                          2L, 2L, 2L, 2L),
                                        .Label = c("conifer", "deciduous"), 
                                        class = "factor")
                   ),
              .Names = c("species_group_label", "prediction", "error", 
                         "grouping"), 
              class = "data.frame", row.names = c(NA, -17L)
              )



```

---
**Copyright:**  
&copy; Forstliche Versuchs- und Forschungsanstalt Baden-Württemberg
Wonnhaldestraße 4, 79100 Freiburg, [www.fva-bw.de](www.fva-bw.de).  

To the extent possible under law, Forstliche Versuchs- und Forschungsanstalt 
Baden-Württemberg has waived all copyright and related or neighboring rights to
Programmieren in **R**. This work is published from: Germany. 
To view a copy of this license, visit 
[https://creativecommons.org/publicdomain/zero/1.0/legalcode](https://creativecommons.org/publicdomain/zero/1.0/legalcode) 
.
<hr style="height:3px;border:none;color:#333;background-color:#333;" />
<p align="right">
**Last modified:** 2016-09-15, 10:25
</p>

``` {r, echo = FALSE}
# I turn help back on.
options(list(pager = file.path(R.home(), "bin/pager")))
``` 
``` {r, echo = FALSE}
# I turn help back on.
options(list(pager = file.path(R.home(), "bin/pager")))
``` 


